##JVM学习方法论
* 从书本学习
* 从人学习（总结、思考、记笔记）
* 持久化所学的东西（输入~输出）
* 个人脱离公司有更好的发展，即自己有更好的溢价能力
* 为啥掌握了的技术过段时间就忘记了？
* 应用框架的学习 先学会使用，让项目跑起来，然后在研究原理；

##如何学习JVM
* R大 JVM专家
* 学的越多，不知道的越多
* 基于JVM的各种动态与静态语言生态圈已经异常繁荣（重要性）
* jvisualvm

##类加载
* 在Java代码中，类型的加载、连接、初始化过程都是在程序运行期间完成的（类型是定义的class、interface）
* 提供了更大的灵活性，增加了更多的可能性
* Java虚拟机与程序的生命周期（如下几种情况下，Java虚拟机将结束生命周期）
  * 1.执行了System.exit()方法
  * 2.程序正常执行退出
  * 3.程序在执行过程中遇到了异常或错误而异常终止
  * 4.由于操作系统出现错误而导致Java虚拟机进程终止
* 加载：查找并加载类的二进制数据
* 连接：验证：确保被加载的类的正确性 准备：为类的静态变量分配内存，并将其出书化为默认值 解析：把类中的符号引用转换为直接引用
* 初始化：为类的静态变量赋予正确的初始值
* 使用：
* 卸载：

* Java程序对类的使用方式可分为两种 
    1.主动使用 
        创建类的实例
        访问某个类或接口的静态变量，或者对该静态变量赋值
        调用类的静态方法 getstatic putstatic invokestatic
        反射（Class.forName("aaa")）
        初始一个类的子类 （class Parent{} class Child extends Parent{}）
        Java虚拟机启动时被标明为启动类的类（Java Test）
        JDK1.7开始提供的动态语言支持（java.lang.invoke.MethodHandle实例的解析结果REF_getStatic,REF_putStatic,REF_invokeStatic句柄对应的类没有初始化，则初始化）
    2.被动使用（除了上述情形，其他使用Java类的方式都是被看作被动使用，不会导致类的初始化）
* 所有的Java虚拟机实现必须在每个类或接口被Java程序""首次主动使用"时才初始化他们
* 类的加载指的是将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在内存中创建一个java.lang.Class对象，（规范并未说明Class对象位于哪里，HotSpot虚拟机将其放在了方法区中）用来封装类在方法区内的数据结构
*加载.class文件的方式
    从本地系统中直接加载
    通过网络下载.class文件
    从zip,jar等归档文件中加载.class文件
    从专有数据库中提取.class文件
    将Java源文件动态编译为.class文件

##类加载流程
* 开始->装载HelloApp了吗？—N->ClassLoader装载顺利-N->抛出异常
                                              -Y->链接
                        -Y->链接->初始化HelloApp->调用HelloApp.main()->结束
* 加载：就是把二进制形式的Java类型读入Java虚拟机中
* 验证：
* 准备：为类变量分配内存，设置默认值。但是在到达初始化之前，类变量都没有初始化为真正的初始值
* 解析：解析过程就是在类型的常量池中寻找类，接口，字段和方法的符号引用，把这些符号引用替换成直接引用的过程
* 初始化：为类变量赋予正确的初始值
* 类实例化：
    为新的对象分配内存 
    为实例变量赋予正确的初始值
    Java编译器为他编译的每一个类都至少生成一个实例初始化方法，在Java的class文件中，这个实例初始化方法被称为"<init>"。针对源代码中每一个类的构造方法，Java编译器都产生一个<init>方法。
* 类加载的最终产品是位于内存中的Class对象
* Class对象封装了类在方法区内的数据结构，并且向Java程序员提供了访问方法区内的数据结构的接口
* 有两种类型的类加载器    
    Java虚拟机自带的类加载器
        根类加载器BootStrap
        扩展类加载器Extension
        系统（应用）类加载器System
    用户自定义的类加载器
        java.lang.ClassLoader的子类
        用户可以定制类的加载方式                       
* 类加载器并不需要等到某个类被"首次主动使用"时在加载它
* JVM规范允许类加载器在预料到某个类将要被使用时就预先加载它，如果在预先加载的过程中遇到了.class文件缺失或存在错误，类加载器必须在程序首次主动使用该类时才报告错误（LinkageError错误）
* 如果这个类一直没有被程序主动使用，那么类加载器就不会报告错误
* 类被加载后，就进入连接阶段，连接就是将已经读入到内存的类的二进制数据合并到虚拟机的运行时环境中去

* 类的验证的内容
    类文件的结构检查
    语义检查
    字节码验证
    二进制兼容性的验证
    
* 类的准备 在准备阶段，Java虚拟机为类的静态变量分配内存，并设置默认的初始值。例如对于以下Sample类，在准备阶段，将为int类型的静态变量a分配4个字节的内存空间，并且赋予默认值0，为long类型的静态变量b分配8个字节的内存空间，并且赋予默认值0；
public class Sample{
    private static int a =1;
    public static long b;
    static{
        b=2;
    }
}

* 类的初始化 
    a.在初始化阶段，Java虚拟机执行类的初始化语句，为类的静态变量赋予初始值。在程序中，静态变量的初始化有两种途径：1.在静态变量的声明处进行初始化；2.在静态代码块中进行初始化。例如在以下代码中，静态变量a和b都被显式初始化，而静态变量c没有被显式初始化，它将保持默认值0
    public class Sample{
        private static int a=1;
        public static long b;
        public static long c;
        static{
            b=2;
        }
    }
    b.静态变量的声明语句，以及静态代码块都被看做类的初始化语句，Java虚拟机会按照初始化语句在类文件中的先后顺序来依次执行它们。例如当以下Sample类被初始化后，它的静态变量a的取值为4
    public class Sample{
        static int a=1;
        static { a =2;}
        static { a =4;}
        public static void main(String args[]){
            System.out.println("a="+a);
        }
    }
    c.类的初始化步骤
        1.假如这个类还没有被加载和连接，那就先进行加载和连接
        2.假如类存在直接父类，并且这个父类还没有被初始化，那就先初始化直接父类
        3.假如类中存在初始化语句，那就依次执行这些初始化语句
    d.当Java虚拟机初始化一个类时，要求它的所有父类都已经被初始化，但是这条规则并不适用于接口
        1.在初始化一个类时，并不会先初始化它所实现的接口
        2.在初始化一个接口时，并不会先初始化它的父接口
        因此，一个父接口并不会因为它的子接口或者实现类的初始化而初始化。只有当程序首次使用特定接口的静态变量时，才会导致该接口的初始化
    e.只有当程序访问的静态变量或静态方法确实在当前类或者当前接口定义时，才可以认为是对类或接口的主动使用；    
* 调用ClassLoader类的loadClass方法加载一个类，并不是对类的主动使用，不会导致类的初始化

* 类加载器用来把类加载到Java虚拟机中，从JDK1.2版本开始，类的加载过程采用父类委托机制
* BootStrap类加载器 该类加载器没有父加载器，他负责加载虚拟机的核心类库，如java.lang.*等；java.lang.object就是有根类加载器加载的。根类加载器从系统属性sun.boot.class.path所指定的目录中加载类库。根类加载器的实现依赖于底层操作系统。属于虚拟机的实现的一部分，他并没有继承java.lang.classLoader类
* Extension类加载器 他的父类加载器为根类加载器，它从java.ext.dirs系统属性所指定的目录中加载类库，或者从jdk的安装目录的jre/lib/ext子目录下加载类库。如果把用户创建的jar文件放在这个目录下，也会自动扩展类加载器加载。扩展类加载器就是纯Java类，是java.lang.classLoader类的子类
* System类加载器 他的父类加载器为扩展类加载器，它从环境变量classpath或者系统属性java.class.path所指定的目录中加载类，他是用户自定义的类加载器的默认父加载器。系统类加载器是纯Java类，是java.lang.classLoader类的子类

**********************************************************************************
* 在父亲委托机制中，各个加载器按照父子关系形成了树形结构，除了根类加载器之外，其余的类加载器有且只有一个父类加载器；
* 定义类加载器和初始类加载器
* 获取当前类的ClassLoader clazz.getClassLoader();
* 获取当前线程上下文的ClassLoader Thread.currentThread().getContextClassLoader()
* 获取系统的ClassLoader ClassLoader.getSystemClassLoader()
* 获取调用者的ClassLoader DriverManager.getCallerClassLoader()