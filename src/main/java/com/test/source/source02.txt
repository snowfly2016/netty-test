分析源码不是为了分析而分析，价值在于这么设计背后的真实原理？

为何有两个EventLoopGroup？

channel 中是NioServerSocketChannel如何封装Java的NIO的？为何这样设计呢？

Reactor模式解析  反应器模式

Proactor模式 网络编程

netty整体架构是reactor模式的完整体现

Responsive Design 响应式设计

Scalable IO in Java Doug Lea

Reactor Douglas 论文

netty3 netty4区别？

***************************************
Reactor角色构成：（一共有5种角色构成，以下的角色基于Reactor Douglas 论文）

1.handle（句柄或者描述符）：本质上表述一种资源，是由操作系统提供的，该资源用于表示一个个的事件，比如说文件描述符，或是针对网络编程中的socket描述符。事件既可以来自内部，也可以来自外部，外部事件比如说客户端连接请求，客户端发送过来数据等；内部事件比如说操作系统产生的定时器事件等，它本身就是一个文件描述符。handle本身是事件产生的发源地。

2.synchronous event demultipelxer（同步事件分离器）：它本身是一个系统调用，用于等待事件的发生（事件可能是一个，也可能是多个）。调用方在调用它的时候会被阻塞，一直阻塞到同步事件分离器上有事件产生为止。对于linux来说，同步事件分离器指的就是常用的IO多路复用机制，比如说select、poll、epoll等。在Java NIO领域中，同步事件分离器对应的组件就是selector，对应的阻塞方法就是select方法。

3.event handler（事件处理器）：本身由多个回调方法构成，这些回调方法构成了与应用相关的对于某个事件的反馈机制。Netty相比于Java NIO来说，在事件处理器这个角色上进行了一个升级，它为我们开发者提供了大量的回调方法，供我们在特定时间产生时实现相应的回调方法进行业务逻辑处理。

4.concrete event handler(具体事件处理器):是事件处理器的实现，它本身实现了事件处理器所提供的各个回调方法，从而实现了特定于业务的逻辑，它本质上就是我们所编写的一个个的处理器的实现。 channelRead0方法是谁调用的？workgroup ->subreactor

5.initiation dispatcher（初始分发器）：它实际上就是Reactor角色，它本身定义了一些规范，这些规范用于控制事件的调度方式，同时又提供了应用于事件处理器的注册、删除等设施。它本身是整个事件处理器的核心所在，initiation dispatcher会通过同步事件分离器来等待事件的发生，一旦事件发生，initiation dispatcher首先会分离出每一个事件，然后调用事件处理器，最后调用相关的回调方法来处理这些事件。







